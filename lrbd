#!/usr/bin/python
# Copyright (C) 2015 Eric Jackson <ejackson@suse.com>

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, see
# <http://www.gnu.org/licenses/>.


from os.path import basename
import glob
import argparse
import rados, rbd, json
import sys, tempfile, os
from subprocess import call, Popen, PIPE
import re, socket
import pprint
from collections import defaultdict
import os.path



def popen(cmd):
    """
    Execute a command, print both stdout and stderr, and exit unless 
    successful.
 
        cmd - an array of strings of the command
    """

    print " ".join(cmd)
    proc = Popen(cmd, stdout=PIPE, stderr=PIPE)
    for line in proc.stdout:
        print line.rstrip('\n')
    for line in proc.stderr:
        print line.rstrip('\n')
    proc.wait()
    if (proc.returncode != 0):
        exit(proc.returncode)

def strip_comments(text):
    """
    Remove all entries beginning with # to end of line

        text - a string
    """
    return(re.sub(re.compile("#.*?\n" ) ,"" ,text))
        
def lstrip_spaces(text):
    """
    Remove 12 spaces 

        text - a string
    """
    return(re.sub(re.compile("^ {12}", re.MULTILINE), "", text))

def check_keys(keys, data, description):
    """
    Verify that keys are present in data

        keys - an array of strings
        data - a dict
        description - a string
    """
    for key in keys:
        if not key in data:
            print "Missing attribute '{}' in {}".format(key, description)
            exit(1)

def compare_settings(keys, current, config):
    """
    Verify that values are identical

        keys - an array of strings
        current - a dict
        config - a dict, possible superset of current
    """
    for key in keys:
        if (current[key] != config[key]):
            return(False)
    return(True)

def iqn(entry):
    """
    Return the target iqn if exists, otherwise default to the first iqn listed
    in the _target section, which is host specific.  

        entry - a dictionary, typically an image entry
    """
    if 'target' in entry:
        return(entry['target'])
    else:
        return(Common.config['iqns'][0])

class Common:
    """
    Sharing common configurations such as Common.config
    """
    pass


class Content:
    """
    Contains operations for reading, editing and saving the configuration to
    Ceph. 
    """

    def __init__(self):
        """
        The variable self.current holds the JSON structure of the existing 
        configuration.
        """
        self.current = {}
 
    def edit(self, editor):
        """
        Edit the global configuration in a text editor.  Submitted changes
        are validated.  Errors are displayed after an edit session allowing
        a user to start another edit session or interrupt the program.

            editor - specify another editor, defaults to vim
        """
        self.current = Common.config
        if (editor == None):
            EDITOR = os.environ.get('EDITOR', '/usr/bin/vim') 
        else:
            EDITOR = editor

        if (not self.current['_auth'] and 
            not self.current['_target'] and
            not self.current['pools']):
            initial_message = self.instructions()
        else:
            initial_message = json.dumps(self.current, indent=2, sort_keys=True)

        with tempfile.NamedTemporaryFile(suffix=".tmp") as tmpfile:
            tmpfile.write(initial_message)
            tmpfile.flush()

            valid = False
            while (not valid):
                call([EDITOR, tmpfile.name])
                submitted = strip_comments(open(tmpfile.name).read())
                valid = (self.validate(submitted) and 
                         self.verify_mandatory_keys(submitted))
                if (not valid):
                    try:
                        raw_input("Press enter to edit or Ctrl-C to quit ")
                    except KeyboardInterrupt, e:
                        print "\nBye"
                        exit(1)
            self.submitted = json.loads(submitted)

    def instructions(self):
        """
        Initial instructions when no configuration exists
        """
        return(lstrip_spaces("""#
            #
            # lrbd stores an iSCSI configuration in Ceph and applies the 
            # configuration to a host acting as a gateway between Ceph and an 
            # initiator (i.e. iSCSI client)
            #
            # Since no configuration exists, the simplest example is provided 
            # below.  Replace 'rbd', 'igw1', 'archive' and 
            # 'iqn.1996-04.de.suse:01:abcdefghijkl' with your pool, host, 
            # rbd image name and initator iqn.
            #
            # Alternatively, check the samples/ subdirectory.  Select the most 
            # suitable configuration and customize.  Apply your configuration 
            # with 'lrbd -f <filename>'.  For additional options, run 'lrbd -h'
            #
              {
                "pools": [
                  { "pool": "rbd",
                    "gateways": [
                      { "host": "igw1",
                        "images": [
                          { "image": "archive",
                            "iqn": "iqn.1996-04.de.suse:01:abcdefghijkl" 
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
             

            #\n"""))

    def read(self, file):
        """
        The counterpart to using an editor, this method reads a file directly
        and runs the same validation.

            file - a text configuration file
        """
        if not os.path.isfile(file):
            print "ERROR: file '{}' does not exist".format(file)
            exit(1) 
        text = strip_comments(open(file).read())
        if (self.validate(text) and self.verify_mandatory_keys(text)):
               #print "submitting:"
               self.submitted = json.loads(text)
               #print self.submitted
       

    def validate(self, text):
        """
        JSON format is finicky about trailing commas and such.  Print
        the errors to stdout.

            text - a string of the entire configuration
        """
        try:
          content = json.loads(text)
        except ValueError, e:
          print e
          return False
        return True

    def verify_mandatory_keys(self, text):
        """
        Checks for dictionary keys related to the global data structure.

            text - a string of the entire configuration
        """
        content = json.loads(text)
        if not 'pools' in content:
            print "Mandatory key 'pools' is missing"
            return False
        if not content['pools']:
            print "pools have no entries"
            return False
        if not 'gateways' in content['pools'][0]:
            print "Mandatory key 'gateways' is missing"
            return False
        if not content['pools'][0]['gateways']:
            print "gateways have no entries"
            return False
        if not 'host' in content['pools'][0]['gateways'][0]:
            print "Mandatory key 'host' is missing"
            return False
        if not 'images' in content['pools'][0]['gateways'][0]:
            print "Mandatory key 'images' is missing"
            return False

        # Authentication section is optional, but keys are required when present
        if '_auth' in content:
            for entry in content['_auth']:
                if not ('host' in entry or 'target' in entry):
                    print "Mandatory key 'host' or 'target' is missing from _auth"
                    return False
        return True


    def save(self):
        """
        Write the configuration to Ceph.  Remove any entries that were deleted
        from the submission.  Data is subdivided for simpler host retrieval.

        Stores the following attributes:
            _target - static iqn for each gateway host.  Stored on each 
                      configuration object in every pool if it exists.  
            _<host> - authentication information for gateway host
            _<target> - authentication information for target
            <host>  - pool information for gateway host
        """
        if self.submitted != self.current:
            hosts = {}
            attr = Attributes() 
            if ('pools' in self.current and self.current['pools']):
                for pool in self.current['pools']: 
                    hosts[pool['pool']] = []
                    for gateway in pool['gateways']:
                        hosts[pool['pool']].append(gateway['host'])
                for pool in self.submitted['pools']: 
                    for gateway in pool['gateways']:
                        hosts[pool['pool']].remove(gateway['host'])
                    for host in hosts[pool['pool']]:
                        attr.remove(str(pool['pool']), str(host))

            if ('_auth' in self.current and self.current['_auth'] 
                and not '_auth' in self.submitted):
                for pool in self.submitted['pools']: 
                    attr.remove_auth(str(pool['pool']))
                    
            for pool in self.submitted['pools']: 
                for gateway in pool['gateways']:
                    attr.write(str(pool['pool']), 
                        str(gateway['host']), json.dumps(gateway))
                if '_auth' in self.submitted:
                    for entry in self.submitted['_auth']: 
                        if 'host' in entry:
                            attr.write(str(pool['pool']), 
                                str('_' + entry['host']), json.dumps(entry))
                        elif 'target' in entry:
                            attr.write(str(pool['pool']), 
                                str('_' + entry['target']), json.dumps(entry))
                        else:
                            print "ERROR: auth entry must contain either 'host' or 'target'"
                            exit(1)
                if '_target' in self.submitted:
                    attr.write(str(pool['pool']), 
                        str('_target'), json.dumps(self.submitted['_target']))



class Attributes:
    """
    Methods for updating and removing extended attributes within Ceph.
    TODO: Rethink the connect/shutdown
    """

    def __init__(self):
        pass

    def write(self, pool, key, attrs):
        """
        Write an empty object and set an extended attribute

            pool - a string, name of Ceph pool
            key - a string, name of gateway host or target
            attrs - a string, json format
        """
        cluster = rados.Rados(conffile=Common.ceph_conf)
        cluster.connect()
        try:
            ioctx = cluster.open_ioctx(pool)
        except rados.ObjectNotFound, e:
            print "ERROR: pool '{}' does not exist".format(pool)
            exit(1)
        ioctx.write_full(Common.config_name, "")
        ioctx.set_xattr(Common.config_name, key, attrs)
        ioctx.close()
        cluster.shutdown()

    def remove(self, pool, attr):
        """
        Remove a specified attribute.  This is necessary when a host has
        been removed from the list of gateways
  
            pool - a string, name of Ceph pool
            attr - a string, name of gateway host
        """
        cluster = rados.Rados(conffile=Common.ceph_conf)
        cluster.connect()
        ioctx = cluster.open_ioctx(pool)
        ioctx.rm_xattr(Common.config_name, attr)
        ioctx.close()
        cluster.shutdown()

    def remove_auth(self, pool):
        """
        Remove authentication attributes for a pool

            pool - a string, name of Ceph pool
        """
        cluster = rados.Rados(conffile=Common.ceph_conf)
        cluster.connect()
        ioctx = cluster.open_ioctx(pool)
        for key, value in ioctx.get_xattrs(Common.config_name):
            if (key[0] == "_" and not key == "_target"):
                ioctx.rm_xattr(Common.config_name, key)
        ioctx.close()
        cluster.shutdown()


class AllPools:
    """
    Manages the entire structure of pools, gateways, images and initiators.  
    All hosts are included.
    """

    def __init__(self):
        """
        A list of pools.  Data structure is label : value throughout. 
        """
        self.pools = []

    def add(self, item):
        """
        Creates another pool entry
        
            item - dict (e.g. "pool": "swimming")
        """
        self.pools.append({})
        self.pools[-1]['pool'] = item

    def append(self, key, item):
        """
        Adds another JSON structure to 'key' in the same named pool above.

            key - a string such as "gateways"
            item - JSON structure of host, images and portals
        """
        if not key in self.pools[-1]:
            self.pools[-1][key] = []
        self.pools[-1][key].append(item)

    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.pools)


class Pools:
    """
    Manages a collapsed, host specific view of pools.  No lists are necessary
    since all information pertains to a specific host.
    """

    def __init__(self):
        """
        A dict of pools, restricted to a specific host.  Data structure is
        entirely dict (or hash) driven for simpler methods later.
        """
        self.pools = {}

    def assign(self, key, item):
        """
        Set pool name to JSON structure

            key - string name of pool
            item - JSON structure of host, images and portals
        """
        self.pools[key] = item

    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.pools)


class Targets:
    """
    Manages the target section of the extended attributes (i.e. all data stored 
    under _target).
    """

    def __init__(self):
        """
        List of targets, entires are either host and iqn or hosts and iqn
        """
        self.targets = []

    def add(self, item):
        """
        Add entire structure, identical copies are stored in each pool so 
        only one is needed.
        """
        if not self.targets:
            self.targets.extend(item)

    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.targets)
     
    def get(self, hostname):
        """
        Return only iqn values filtered by hostname

            hostname - string of gateway host
        """
        targets = []
        for entry in self.targets:
            if 'hosts' in entry:
                for host in entry['hosts']:
                    if (hostname == host):
                        targets.append(entry['iqn'])
        return(targets)

    def only(self, hostname):
        """
        Remove all host entries that do not match hostname

            hostname - string of gateway host
        """
        for entry in self.targets:
            if 'host' in entry:
                if (hostname != entry['host']):
                       self.targets.remove(entry)

class Authentications:
    """
    Manages the authentication section under the extended attribute _auth.
    This section is optional, but relates to gateways and targets 
    independently.  Authentication can none, tpg (common credentials) or
    acls (host specific credentials).
    """

    def __init__(self):
        """
        List of authentications.  Absent and present but disabled are 
        permitted.
        """
        self.authentications = []

    def add(self, item):
        """
        Add entire structure, identical copies are stored in each pool so 
        only one is needed.
        """
        if not self.exists(item):
            self.authentications.append(item)

    def exists(self, item):
        """
        helper function for above since "item in list" didn't work for
        list of lists
        """
        present = False
        for entry in self.authentications:
            for attr in [ 'host', 'target' ]:
                if attr in item and attr in entry:
                    if (item[attr] == entry[attr]):
                        present = True
                        break
        return(present)

    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.authentications)


class Configs:
    """
    Read the configuration from Ceph for both global and host only 
    configurations.  Merges pools, targets and authentications into
    larger structures.  Assigns to Common.* for sharing with other
    classes.
    """

    def __init__(self, config_name, ceph_conf, hostname):
        """
        Set initial overrides and assign to Common configuration

            config_name - a string for the name of the configuration object
                          in Ceph
            ceph_conf - an alternative Ceph configuration file
            hostname - specify an alternative gateway host
        """
        self.global_config = {}

        if (config_name == None):
            self.config_name = "lrbd.conf"
        else:
            self.config_name = config_name

        if (ceph_conf == None):
            self.ceph_conf = "/etc/ceph/ceph.conf"
        else:
            self.ceph_conf = ceph_conf

        if not os.path.isfile(self.ceph_conf):
            print "ERROR: {} does not exist".format(self.ceph_conf)
            exit(1)

        if (hostname == None):
            self.hostname = socket.gethostname()
        else:
            self.hostname = hostname

        Common.config_name = self.config_name
        Common.ceph_conf = self.ceph_conf
        Common.hostname = self.hostname

    def retrieve(self):
        """
        Scan all configuration objects and build a structure containing
        all gateway hosts.  Merge pools, _auth and _target into Common.config 
        """
        cluster = rados.Rados(conffile=self.ceph_conf)

        try:
            cluster.connect()
        except rados.ObjectNotFound, e:
            print "ERROR: check for missing keyring"
            exit(1)
    
        p = AllPools()
        t = Targets()
        a = Authentications()

        for pool in cluster.list_pools():
            ioctx = cluster.open_ioctx(pool)
            try:
                ioctx.stat(self.config_name) # Check for object
            except rados.ObjectNotFound, e:
                # No configuration for pool, skipping
                print "INFO: No configuration object {} in pool {}".format(self.config_name, pool)
                continue

            p.add(pool)
            t.add(json.loads(ioctx.get_xattr(self.config_name, '_target')))

            attrs = ioctx.get_xattrs(self.config_name)
            for key, value in attrs:
                if key == "_target":
                    continue
                elif key[0] == "_":
                    a.add(json.loads(value))
                    
                else:
                    p.append('gateways', json.loads(value))
            ioctx.close
        cluster.shutdown()

        self.global_config['pools'] = p.pools
        self.global_config['_auth'] = a.authentications
        self.global_config['_target'] = t.targets
        Common.config = self.global_config

    def retrieve_host(self):
        """
        Scan all configuration objects and build a structure containing
        one gateway host.  Merge pools, _auth and _target into Common.config 
        """
        cluster = rados.Rados(conffile=self.ceph_conf)

        try:
            cluster.connect()
        except rados.ObjectNotFound, e:
            print "ERROR: check for missing keyring"
            exit(1)
        p = Pools()
        t = Targets()
        a = Authentications()

        for pool in cluster.list_pools():
            ioctx = cluster.open_ioctx(pool)
            try:
                value = ioctx.get_xattr(self.config_name, self.hostname)
            except rados.ObjectNotFound, e:
                print "INFO: Object {} does not exist in pool {}".format(self.config_name, pool)
                continue
            except rados.NoData, e:
                print "INFO: No configuration for {} in pool {}".format(self.hostname, pool)
                continue
            p.assign(pool, json.loads(value))
            t.add(json.loads(ioctx.get_xattr(self.config_name, '_target')))
            a.add(json.loads(ioctx.get_xattr(self.config_name, '_' + self.hostname)))
            for target in t.get(self.hostname):
                a.add(json.loads(ioctx.get_xattr(self.config_name, str('_' + target))))
                
        cluster.shutdown()
        t.only(self.hostname)

        self.global_config['pools'] = p.pools
        self.global_config['_auth'] = a.authentications
        self.global_config['_target'] = t.targets
        Common.config = self.global_config

    def display(self):
        """
        JSON dump of structure to user.  Keys are sorted which makes the 
        format obnoxious when reviewing.  TODO: custom JSON output with
        keys sorted by significance.
        """
        print json.dumps(self.global_config, indent=4, sort_keys=True)

    def wipe(self):
        """
        Remove configuration objects from all pools
        """
        cluster = rados.Rados(conffile=self.ceph_conf)

        cluster.connect()
        pools = cluster.list_pools()
        for pool in pools:
            ioctx = cluster.open_ioctx(pool)
            try:
                ioctx.remove_object(self.config_name)
            except rados.ObjectNotFound, e:
                print "INFO: No object {} to remove from pool {}".format(self.config_name, pool)
            ioctx.close
        cluster.shutdown()

    def clear(self):
        """
        Reset any targetcli configuration.  

        Note: the clearconfig option is missing from the current targetcli
        which would remove the additional dependencies
        """
        cmds = [ [ "/usr/sbin/tcm_fabric", "--unloadall" ],
                 [ "/usr/sbin/lio_node", "--unload" ],
                 [ "/usr/sbin/tcm_node", "--unload" ] ]
        for cmd in cmds:
            popen(cmd)


class Images:
    """
    Manages mapping and unmapping RBD images
    """

    def __init__(self):
        """
        Parse and store 'rbd showmapped'
        """
        self.mounts = {}
        proc = Popen(["rbd", "showmapped"], stdout=PIPE, stderr=PIPE)
        for line in proc.stdout:
                results = re.split(r'\s+', line)
                if (results[0] == 'id'):
                    continue
                self.mounts[ ":".join([ results[1], results[2] ]) ] = results[4]  

    def map(self):
        """
        Create the commands to map each rbd device
        """
        self.map_cmds = []
        pools = Common.config['pools']
        for pool in pools.keys():
            for entry in pools[pool]['images']:
                if ":".join([ pool, entry['image'] ]) in self.mounts.keys():
                    continue
                self.map_cmds.append([ "rbd", "-p", pool, "map", entry['image'] ])
        for cmd in self.map_cmds:
            popen(cmd)

    def unmap(self):
        """
        Unmount all rbd images
        """
        for mount in self.mounts.keys():
            popen([ "rbd", "unmap", self.mounts[mount]])


class Backstores:
    """
    Creates the necessary backstores via targetcli for each RBD image.
    """

    def __init__(self):
        """
        Create commands for creating each backstore.  Skip existing. 
        """
        self.cmds = []
        pools = Common.config['pools']
        for pool in pools.keys():
            for entry in pools[pool]['images']:
                cmd = [ "targetcli", "/backstores/iblock", "create", 
                        "name={}".format(entry['image']), 
                        "dev=/dev/rbd/{}/{}".format(pool, entry['image']) ]
                backstore = glob.glob("/sys/kernel/config/target/core/iblock_*/{}".format(entry['image']))
                if not backstore: 
                    self.cmds.append(cmd)

    def create(self):
        """
        Execute saved commands
        """
        for cmd in self.cmds:
            popen(cmd)

class Iscsi:
    """
    Creates iscsi entries with provided static target iqns or dynamically
    generates one if none are provided.
    """

    def __init__(self):
        """
        Find all targets in _target.  Append to cmds all that do not exist. 
        If no targets are provided, set cmds to a single base command.
        """
        self.cmds = []
        self.iqns = []
        for target in Common.config['_target']:
            self.iqns.append(target['iqn'])

        base = [ "targetcli", "/iscsi", "create" ]

        if self.iqns:
            for iqn in self.iqns:
                path = glob.glob("/sys/kernel/config/target/iscsi/{}".format(iqn))
                if not path:
                    cmd = list(base)
                    cmd.append(iqn)
                    self.cmds.append(cmd)
        else:
            cmd = base
            self.cmds.append(cmd)

    def create(self):
        """
        Execute commands and assign list of targets to Common.config['iqns']
        """
        for cmd in self.cmds:
            popen(cmd)
        if self.iqns:
            Common.config['iqns'] = self.iqns
        else:
            path = glob.glob("/sys/kernel/config/target/iscsi/iqn*")
            Common.config['iqns'] = [ basename(path[0]) ]


class Luns:
    """
    Manages the creation and mapping of luns.  Also, provides method for 
    disabling auto add which is necessary for acls.
    """

    def __init__(self):
        """
        Skips existing luns.  Builds commands for each image under the 
        correct target.
        """
        self.cmds = []
        self.luns = []
        self.pools = Common.config['pools']
                
        self.find()
        # Does completed need to be per target now?
        completed = []
        for pool in self.pools.keys():
            for entry in self.pools[pool]['images']:
                if (not entry['image'] in completed and
                    not entry['image'] in self.luns):
                    completed.append(entry['image'])
                    cmd = [ "targetcli", "/iscsi/{}/tpg1/luns".format(iqn(entry)), "create", "/backstores/iblock/{}".format(entry['image']) ] 
                    self.cmds.append(cmd)
                
    def find(self):
        """
        Scan paths for existing luns and save lun name to list
        """
        for pool in self.pools.keys():
            for entry in self.pools[pool]['images']:
                udev_paths = glob.glob("/sys/kernel/config/target/iscsi/{}/tpgt_*/lun/lun_*/*/udev_path".format(iqn(entry)))
                for udev_path in udev_paths:
                    contents = open(udev_path).read()
                    self.luns.append(basename(contents.rstrip('\n')))


    def create(self):
        """
        Disable auto mapping.  Execute saved commands.
        """
        self.disable_auto_add_mapped_luns()
        for cmd in self.cmds:
            popen(cmd)

    def disable_auto_add_mapped_luns(self):
        """
        Allow device to initiator mapping by disabling auto mapping.
        """
        proc = Popen(["targetcli", "get", "global", "auto_add_mapped_luns"], stdout=PIPE, stderr=PIPE)
        for line in proc.stdout:
            results = re.split(r'=', line)
            if (results[1].rstrip() != 'false'):
                cmd = [ "targetcli", "set", "global", "auto_add_mapped_luns=false" ]
                popen(cmd)

    def map(self):
        """
        Creates mapped luns under each initiator.  Skips existing. 
        """
        for pool in self.pools.keys():
            for entry in self.pools[pool]['images']:
                lun_path = glob.glob("/sys/kernel/config/target/core/iblock_*/{}".format(entry['image']))
                if not lun_path:
                    print "ERROR: iblock backstore for '{}' image does not exist".format(entry['image'])
                    exit(1)
                lun = re.split("[/_]", lun_path[0])[7]

                if '_auth' in Common.config:
                    for auth in Common.config['_auth']:
                        if 'acls' in auth and auth['authentication'] == "acls":
                            for acl in auth['acls']:

                                path = glob.glob("/sys/kernel/config/target/iscsi/{}/tpgt_*/acls/{}/lun_{}".format(iqn(entry), entry['iqn'], lun))
                                if not path:
                                    cmd = [ "targetcli", "/iscsi/{}/tpg1/acls/{}".format(iqn(entry), entry['iqn']), "create", lun, "0" ] 
                                    popen(cmd)



class Portals:
    """
    Manage the creation of portals, skipping existing.  If none are provided
    in the configuration, assign the base targetcli command which is select
    a default interface.
    """

    def __init__(self):
        """
        """
        self.cmds = []
        self.luns = []
        self.pools = Common.config['pools']

        for pool in self.pools.keys():
            if 'portals' in self.pools[pool]:
                for entry in self.pools[pool]['portals']:
                    cmd = [ "targetcli", "/iscsi/{}/tpg1/portals".format(iqn(entry)), "create", entry['portal'] ] 
                    portal = glob.glob("/sys/kernel/config/target/iscsi/{}/tpgt_*/np/{}*".format(iqn(entry), entry['portal']))
                    if not portal:
                        self.cmds.append(cmd)
            else:
                cmd = [ "targetcli", "/iscsi/{}/tpg1/portals".format(iqn({})), "create" ] 
                portal = glob.glob("/sys/kernel/config/target/iscsi/{}/tpgt_*/np/*".format(iqn({})))
                if not portal:
                    self.cmds.append(cmd)

    def create(self):
        """
        Execute saved commands.  Skip redundant commands from multiple image
        entries.
        """
        for cmd in self.uniq(self.cmds):
            popen(cmd)

    def uniq(self, cmds):
        """
        Remove redundant entries from list of lists
        """
        u = {}
        c = []
        for cmd in cmds:
            u[" ".join(cmd)] = ''
        for k in u.keys():
            c.append(k.split())
        return(c)


class Acls:
    """
    Manage acls for each initiator.  Skip existing entries.  

    """

    def __init__(self):
        """
        Scan initiator iqn from image entries and check for corresponding 
        pathnames.  Append to list.

        Scan initiators from _auth section and create commands.  Exclude from
        above.
        """
        self.cmds = []
        self.pools = Common.config['pools']
        initiators = []

        for pool in self.pools.keys():
            for entry in self.pools[pool]['images']:
                paths = glob.glob("/sys/kernel/config/target/iscsi/{}/tpgt_*/acls/*".format(iqn(entry)))
            for path in paths:
                initiators.append(basename(path))

        if '_auth' in Common.config:
            for auth in Common.config['_auth']:
                if 'acls' in auth:
                    for acl in auth['acls']:
                        if not acl['iqn'] in initiators:
                            if 'target' in auth:
                                target = auth['target']
                            else:
                                target = Common.config['_target'][0]['iqn']
                            cmd = [ "targetcli", "/iscsi/{}/tpg1/acls".format(target), "create", acl['iqn'] ] 
                            self.cmds.append(cmd) 

               
    def create(self):
        """
        Execute saved commands
        """
        for cmd in self.cmds:
            popen(cmd)


class Auth:
    """
    Manage the authentications for each target.  Each authentication mode
    contains multiple steps.  Delegate creation of the necessary commands.  
    Execute commands.
    """

    def __init__(self):
        """
        Check for existence of the authentication section and current setting.
        Select appropriate delegation.  Note that discovery authentication
        is independent of normal authentication and optional.
        """
        self.cmds = []

        if '_auth' in Common.config['_auth']:
            for auth in Common.config['_auth']:
                self.target = iqn(auth)
                if auth['authentication'] == "none":
                    self.cmds.append(self.set_noauth(auth))
                elif auth['authentication'] == "tpg":
                    self.cmds.append(self.select_tpg(auth))
                elif auth['authentication'] == "acls":
                    self.cmds.append(self.select_acls(auth))
                else:
                    print "InvalidAuthentication: authentication must be one of tpg, acls or none"
                    exit(1)
                self.cmds.extend(self.select_discovery())
        else:
            self.cmds.append(self.set_noauth({}))

    def set_noauth(self, auth):
        """
        Disable authentication
        """
        path = "/sys/kernel/config/target/iscsi/{}/tpgt_1/attrib".format(iqn(auth))
        authentication = open(path + "/authentication").read().rstrip('\n')
        demo_mode_write_protect = open(path + "/demo_mode_write_protect").read().rstrip('\n')
        
        if ((authentication == "0") and
           (demo_mode_write_protect == "0")):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1".format(iqn(auth)), "set", "attribute", "authentication=0", "demo_mode_write_protect=0" ] 
        return(cmd)

    def select_discovery(self):
        """
        Discovery is optional, can be completely disabled, have only mutual 
        disabled or be completely enabled.  Delegate appropriately.
        """
        cmds = []
        for auth in Common.config['_auth']:
            if "discovery" in auth:
                if auth['discovery']['auth'] == "enable":
                    if "mutual" in auth['discovery']:
                        if auth['discovery']['mutual'] == "enable":
                            cmds.append(self.set_discovery_mutual(auth))
                        else:
                            cmds.append(self.set_discovery(auth))
                    else:
                        cmds.append(self.set_discovery(auth))
                else:
                    cmds.append(self.set_discovery_off())
            else:
                cmds.append(self.set_discovery_off())
            return(cmds)

    def set_discovery(self, auth):
        """
        Call targetcli to only set the discovery userid and password.  Check
        current settings.
        """
        keys = [ 'userid', 'password']
        check_keys(keys, auth['discovery'], "discovery under _auth")

        path = "/sys/kernel/config/target/iscsi/discovery_auth"
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        
        if compare_settings(keys, current, auth['discovery']):
            return([])

        cmd = [ "targetcli", "/iscsi", "set", "discovery_auth", "enable=1",
                 "userid={}".format(
                     auth['discovery']['userid']), 
                 "password={}".format(
                     auth['discovery']['password']) ] 
        return(cmd)

    def set_discovery_mutual(self, auth):
        """
        Call targetcli to set both normal and mutual discovery authentication.
        Checks current settings.
        """
        keys = [ 'userid', 'password', 'userid_mutual', 'password_mutual']
        check_keys(keys, auth['discovery'], "discovery under _auth")

        path = "/sys/kernel/config/target/iscsi/discovery_auth"
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        current['userid_mutual'] = open(path + "/userid_mutual").read().rstrip('\n')
        current['password_mutual'] = open(path + "/password_mutual").read().rstrip('\n')
        
        if compare_settings(keys, current, auth['discovery']):
            return([])


        cmd = [ "targetcli", "/iscsi", "set", "discovery_auth", "enable=1", 
                 "userid={}".format(
                     auth['discovery']['userid']), 
                 "password={}".format(
                     auth['discovery']['password']), 
                 "mutual_userid={}".format(
                     auth['discovery']['userid_mutual']), 
                 "mutual_password={}".format(
                     auth['discovery']['password_mutual']) ] 
        return(cmd)

    def set_discovery_off(self):
        """
        Disable discovery
        """
        cmd = [ "targetcli", "/iscsi", "set", "discovery_auth", "enable=0" ]
        return(cmd)

    def select_tpg(self, auth):
        """
        TPG is optional, can have only mutual disabled or be completely 
        enabled.  Delegate appropriately.  TPG allows a common userid and
        password for all initiators.
        """
        cmds = []
        if "mutual" in auth['tpg']:
            if auth['tpg']['mutual'] == "enable":
                cmds.append(self.set_tpg_mutual(auth))
                cmds.append(self.set_tpg_mode(auth))
            else:    
                cmds.append(self.set_tpg(auth))
                cmds.append(self.set_tpg_mode(auth))
        else:
            cmds.append(self.set_tpg(auth))
            cmds.append(self.set_tpg_mode(auth))
        return(cmds)


    def set_tpg(self, auth):
        """
        Call targetcli to set only the common userid and password.  Check
        current setting.
        """
        for target in self.targets:
            keys = [ 'userid', 'password']
            check_keys(keys, auth['tpg'], "tpg under _auth")
                    
            path = "/sys/kernel/config/target/iscsi/{}/tpgt_1/auth".format(iqn(auth))
            current = {}
            current['userid'] = open(path + "/userid").read().rstrip('\n')
            current['password'] = open(path + "/password").read().rstrip('\n')
            
            if compare_settings(keys, current, auth['tpg']):
                return([])

            cmd = [ "targetcli", "/iscsi/{}/tpg1".format(target), "set", "auth", 
                     "userid={}".format(
                         auth['tpg']['userid']), 
                     "password={}".format(
                         auth['tpg']['password']) ] 
            return(cmd)

    def set_tpg_mutual(self, auth):
        """
        Call targetcli to set both the common and mutual userids and passwords.
        Checks current settings.
        """
        keys = [ 'userid', 'password', 'userid_mutual', 'password_mutual']
        check_keys(keys, auth['tpg'], "tpg under _auth")

        path = "/sys/kernel/config/target/iscsi/{}/tpgt_1/auth".format(iqn(auth))
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        current['userid_mutual'] = open(path + "/userid_mutual").read().rstrip('\n')
        current['password_mutual'] = open(path + "/password_mutual").read().rstrip('\n')
        
        if compare_settings(keys, current, auth['tpg']):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1".format(target), "set", "auth", 
                 "userid={}".format(
                     auth['tpg']['userid']), 
                 "password={}".format(
                     auth['tpg']['password']), 
                 "userid_mutual={}".format(
                     auth['tpg']['userid_mutual']), 
                 "password_mutual={}".format(
                     auth['tpg']['password_mutual']) ] 
        return(cmd)

    def set_tpg_mode(self, auth):
        """
        Enable authentication, allow writing and enable acl generation. Checks
        current settings.
        """
        path = "/sys/kernel/config/target/iscsi/{}/tpgt_1/attrib".format(iqn(auth))
        authentication = open(path + "/authentication").read().rstrip('\n')
        demo_mode_write_protect = open(path + "/demo_mode_write_protect").read().rstrip('\n')
        generate_node_acls = open(path + "/generate_node_acls").read().rstrip('\n')
        
        if ((authentication == "1") and
           (demo_mode_write_protect == "0") and
           (generate_node_acls  == "1")): 
            return([])

        return([ "targetcli", "/iscsi/{}/tpg1".format(iqn(auth)), "set", "attribute", "authentication=1", "demo_mode_write_protect=0", "generate_node_acls=1" ]) 

    def select_acls(self, auth):
        """
        ACLs are optional, can have only mutual disabled or be completely 
        enabled for each initiator.  Delegate appropriately.  ACLs allow a 
        unique userid and password for each initiator.
        
        """
        cmds = []
        for acl in auth['acls']:
            if "mutual" in acl:
                if acl['mutual'] == "enable":
                    cmds.append(self.set_acls_mutual(self, acl, auth))
                else:
                    cmds.append(self.set_acls(self, acl, auth))
            else:
                cmds.append(self.set_acls(self, auth))
        cmds.append(self.set_acls_mode(auth))
        return(cmds)
 
    def set_acls(self, acl, auth):
        """
        Call targetcli to set a userid and password for a specific initiator.
        Checks current setting.
        """
        keys = [ 'userid', 'password']
        check_keys(keys, acl, "acl")

        path = "/sys/kernel/config/target/iscsi/{}/tpgt_1/acls/{}/auth".format(iqn(auth), acl['iqn'])
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        
        if compare_settings(keys, current, acl):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1/acls/{}".format(iqn(auth), acl['iqn']), "set", "auth", 
                 "userid={}".format(acl['userid']),
                 "password={}".format(acl['password']), ] 
        return(cmd)

    def set_acls_mutual(self, acl, auth):
        """
        Call targetcli to set both a normal and mutual authentication for 
        an initiator.  Checks current settings.
        """
        keys = [ 'userid', 'password', 'userid_mutual', 'password_mutual']
        check_keys(keys, acl, "acl")

        path = "/sys/kernel/config/target/iscsi/{}/tpgt_1/acls/{}/auth".format(iqn(auth), acl['iqn'])
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        current['userid_mutual'] = open(path + "/userid_mutual").read().rstrip('\n')
        current['password_mutual'] = open(path + "/password_mutual").read().rstrip('\n')

        if compare_settings(keys, current, acl):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1/acls/{}".format(iqn(auth), acl['iqn']), "set", "auth", 
                 "userid={}".format(acl['userid']),
                 "password={}".format(acl['password']), 
                 "userid_mutual={}".format(acl['userid_mutual']),
                 "password_mutual={}".format(acl['password_mutual']) ] 
        return(cmd)

    def set_acls_mode(self, auth):
        """
        Enable authentication, disable acls generation.  Checks current settings.
        """
        path = "/sys/kernel/config/target/iscsi/{}/tpgt_1/attrib".format(iqn(auth))
        authentication = open(path + "/authentication").read().rstrip('\n')
        demo_mode_write_protect = open(path + "/demo_mode_write_protect").read().rstrip('\n')
        generate_node_acls = open(path + "/generate_node_acls").read().rstrip('\n')
        
        if ((authentication == "1") and
           (demo_mode_write_protect == "0") and
           (generate_node_acls  == "0")): 
            return([])
        return([ "targetcli", "/iscsi/{}/tpg1".format(self.iqn), "set", "attribute", "authentication=1", "demo_mode_write_protect=0", "generate_node_acls=0" ]) 

    def create(self):
        if not self.cmds:
            for cmd in self.cmds:
                popen(cmd)


def main(args):
    """
    Apply stored configuration by default.  Otherwise, execute the alternate
    path from the specified options. 

        args - expects parse_args() result from argparse
    """
    configs = Configs(args.config, args.ceph, args.host)

    if (args.wipe):
        configs.wipe()
    elif (args.clear):
        configs.clear()
        if (args.umount):
            images = Images()
            images.unmap()
    elif (args.umount):
        images = Images()
        images.unmap()
    elif (args.input):
        content = Content()
        content.read(args.input)
        content.save()
    elif (args.output):
        configs.retrieve()
        configs.display()
    elif (args.edit):
        configs.retrieve()
        content = Content()
        content.edit(args.editor)
        content.save()
    elif (args.local):
        configs.retrieve_host()
        configs.display()

    else:
        configs.retrieve_host()
        images = Images()
        images.map()
        backstores = Backstores()
        backstores.create()
        iscsi = Iscsi()
        iscsi.create()
        luns = Luns()
        luns.create()
        portals = Portals()
        portals.create()
        acls = Acls()
        acls.create()
        luns.map()
        auth = Auth()
        auth.create()


# Main
if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('-e', '--edit', action='store_true', dest='edit', default=False,
                    help='edit the rbd configuration for iSCSI')
    parser.add_argument('-E', '--editor', action='store', dest='editor',
                    help='use EDITOR to edit the rbd configuration for iSCSI')
    parser.add_argument('-c', '--config', action='store', dest='config',
                    help='use CONFIG for object, defaults to "lrbd.conf"')
    parser.add_argument('--ceph', action='store', dest='ceph',
                    help='specify the ceph configuration file')
    parser.add_argument('-H', '--host', action='store', dest='host',
                    help='specify the hostname, defaults to "{}"'.format(socket.gethostname()))
    parser.add_argument('-o', '--output', action='store_true', dest='output', 
                    help='display the configuration')
    parser.add_argument('-l', '--local', action='store_true', dest='local', 
                    help='display the host configuration')
    parser.add_argument('-f', '--file', action='store', dest='input', 
                    help='apply the configuration from INPUT')
    parser.add_argument('-u', '--umount', action='store_true', dest='umount', 
                    help='unmount the rbd images')
    parser.add_argument('-W', '--wipe', action='store_true', dest='wipe', 
                    help='wipe the configuration objects from all pools')
    parser.add_argument('-C', '--clear', action='store_true', dest='clear', 
                    help='clear the targetcli configuration')
    
    args = parser.parse_args()
    
    if (args.editor != None):
        args.edit = True
    
    main(args)
