#!/usr/bin/python
# Copyright (C) 2015 Eric Jackson <ejackson@suse.com>

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, see
# <http://www.gnu.org/licenses/>.


import glob, uuid
import argparse
import rados, rbd, json
import sys, tempfile, os
from subprocess import call, Popen, PIPE
import re, socket
import pprint
import os.path
from os.path import basename
import netifaces
from collections import OrderedDict
import logging


# CONFIGFS target path
TARGET="/sys/kernel/config/target"

def popen(cmd):
    """
    Execute a command, print both stdout and stderr, and exit unless 
    successful.
 
        cmd - an array of strings of the command
    """
    print " ".join(cmd)
    proc = Popen(cmd, stdout=PIPE, stderr=PIPE)
    for line in proc.stdout:
        print line.rstrip('\n')
    for line in proc.stderr:
        print line.rstrip('\n')
    proc.wait()
    if (proc.returncode != 0):
        exit(proc.returncode)
    if (logging.getLogger().level <= logging.INFO):
        print ""

def strip_comments(text):
    """
    Remove all entries beginning with # to end of line

        text - a string
    """
    return(re.sub(re.compile("#.*?\n" ) ,"" ,text))
        
def lstrip_spaces(text):
    """
    Remove 12 spaces 

        text - a string
    """
    return(re.sub(re.compile("^ {12}", re.MULTILINE), "", text))

def check_keys(keys, data, description):
    """
    Verify that keys are present in data

        keys - an array of strings
        data - a dict
        description - a string
    """
    for key in keys:
        if not key in data:
            raise ValueError("Missing attribute '{}' in {}".format(key, description))

def compare_settings(keys, current, config):
    """
    Verify that values are identical

        keys - an array of strings
        current - a dict
        config - a dict, possible superset of current
    """
    for key in keys:
        if (current[key] != config[key]):
            return(False)
    return(True)

def iqn(entry):
    """
    Return the target iqn if exists, otherwise default to the first iqn listed
    in the targets section, which is host specific.  

        entry - a dictionary, typically an image entry
    """
    if 'target' in entry:
        return(entry['target'])
    else:
        return(Common.config['iqns'][0])

def addresses():
    """
    Return a list of all ip addresses 
    """
    adds = []
    for interface in netifaces.interfaces():
        addrs = netifaces.ifaddresses(interface)
        try:
            for entry in addrs[netifaces.AF_INET]:
                adds.append(entry['addr'])
            for entry in addrs[netifaces.AF_INET6]:
                # Strip interface
                adds.append(re.split("%", entry['addr'])[0])
        except KeyError, e:
            # skip downed interfaces
            pass
    return(adds)

def uniq(cmds):
    """
    Remove redundant entries from list of lists
    """
    u = {}
    c = []
    for cmd in cmds:
        u[" ".join(cmd)] = ''
    for k in u.keys():
        c.append(k.split())
    return(c)

class Common:
    """
    Sharing common static configurations. 
    """
    config = OrderedDict()

class Runtime:
    """
    Sharing common runtime state.
    """
    config = {}

    @staticmethod
    def tpg(target, entry):
        return(Runtime.config['portals'][target][entry['portal']] 
                    if 'portal' in entry else 1)

class Content:
    """
    Contains operations for reading, editing and saving the configuration to
    Ceph. 
    """

    def __init__(self):
        """
        The variable self.current holds the JSON structure of the existing 
        configuration.
        """
        self.current = {}
 
    def edit(self, editor):
        """
        Edit the global configuration in a text editor.  Submitted changes
        are validated.  Errors are displayed after an edit session allowing
        a user to start another edit session or interrupt the program.

            editor - specify another editor, defaults to vim
        """
        self.current = Common.config
        EDITOR = editor if editor else os.environ.get('EDITOR', 
                                                   '/usr/bin/vim')
        if (not self.current['auth'] and 
            not self.current['targets'] and
            not self.current['pools']):
            initial_message = self.instructions()
        else:
            initial_message = json.dumps(self.current, indent=2)

        with tempfile.NamedTemporaryFile(suffix=".tmp") as tmpfile:
            tmpfile.write(initial_message)
            tmpfile.flush()

            valid = False
            while (not valid):
                call([EDITOR, tmpfile.name])
                submitted = strip_comments(open(tmpfile.name).read())
                valid = (self.validate(submitted) and 
                         self.verify_mandatory_keys(submitted))
                if (not valid):
                    try:
                        raw_input("Press enter to edit or Ctrl-C to quit ")
                    except KeyboardInterrupt, e:
                        raise SystemExit("\nBye")
            self.submitted = json.loads(submitted, object_pairs_hook=OrderedDict)

    def instructions(self):
        """
        Initial instructions when no configuration exists
        """
        return(lstrip_spaces("""#
            #
            # lrbd stores an iSCSI configuration in Ceph and applies the 
            # configuration to a host acting as a gateway between Ceph and an 
            # initiator (i.e. iSCSI client)
            #
            # Since no configuration exists, the simplest example is provided 
            # below.  Replace 'rbd', 'igw1', 'archive' and 
            # 'iqn.1996-04.de.suse:01:abcdefghijkl' with your pool, host, 
            # rbd image name and initator iqn.
            #
            # Alternatively, check the samples/ subdirectory.  Select the most 
            # suitable configuration and customize.  Apply your configuration 
            # with 'lrbd -f <filename>'.  For additional options, run 'lrbd -h'
            #
              {
                "pools": [
                  { "pool": "rbd",
                    "gateways": [
                      { "host": "igw1",
                        "tpg": [
                          { "image": "archive",
                            "initiator": "iqn.1996-04.de.suse:01:abcdefghijkl" 
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
             

            #\n"""))

    def read(self, file):
        """
        The counterpart to using an editor, this method reads a file directly
        and runs the same validation.

            file - a text configuration file
        """
        if not os.path.isfile(file):
            raise IOError("file '{}' does not exist".format(file))
        text = strip_comments(open(file).read())
        if (self.validate(text) and self.verify_mandatory_keys(text)):
               self.submitted = json.loads(text, object_pairs_hook=OrderedDict)
        else:
            raise RuntimeError("file {} failed validation".format(file))
       

    def validate(self, text):
        """
        JSON format is finicky about trailing commas and such.  Print
        the errors to stdout.

            text - a string of the entire configuration
        """
        try:
          content = json.loads(text)
        except ValueError, e:
          logging.error(e)
          return False
        return True

    def verify_mandatory_keys(self, text):
        """
        Checks for dictionary keys related to the global data structure.

            text - a string of the entire configuration
        """
        content = json.loads(text)
        if not 'pools' in content:
            raise ValueError("Mandatory key 'pools' is missing")
        if not content['pools']:
            raise ValueError("pools have no entries")
        if not 'gateways' in content['pools'][0]:
            raise ValueError("Mandatory key 'gateways' is missing")
        if not content['pools'][0]['gateways']:
            raise ValueError("gateways have no entries")
        if not ('host' in content['pools'][0]['gateways'][0] or
            'target' in content['pools'][0]['gateways'][0]):
            raise ValueError("Mandatory key 'host' or 'target' is missing")
        if not 'tpg' in content['pools'][0]['gateways'][0]:
            raise ValueError("Mandatory key 'tpg' is missing")

        # Authentication section is optional, but keys are required when present
        if 'auth' in content:
            for entry in content['auth']:
                if not ('host' in entry or 'target' in entry):
                    raise ValueError("Mandatory key 'host' or 'target' is missing from auth")
        return(True)


    def save(self):
        """
        Write the configuration to Ceph.  Remove any entries that were deleted
        from the submission.  Data is subdivided for simpler host retrieval.

        Stores the following attributes:
            targets - static iqn for each gateway host.  Stored on each 
                      configuration object in every pool if it exists.  
            portals - named groups of network addresses
            _<host> - authentication information for gateway host
            _<target> - authentication information for target
            <host>  - pool information for gateway host
            <target>  - pool information for redundant target
        """
        if self.submitted != self.current:
            logging.debug("Saving...")
            conn = Cluster()
            with conn as cluster:
                self.attr = Attributes(cluster) 
                self._remove_absent_entry()
                self._remove_absent_auth()

                        
                for pool in self.submitted['pools']: 
                    if 'gateways' in pool:
                        for gateway in pool['gateways']:
                            self._write_host(pool, gateway)
                            self._write_target(pool, gateway)
                    if 'auth' in self.submitted:
                        self._write_auth(pool)
                    if 'targets' in self.submitted:
                        self._write_targets(pool)
                    if 'portals' in self.submitted:
                        self._write_portals(pool)


    def _remove_absent_entry(self):
        """
        Remove host or target entries that have been deleted from the 
        submitted configuration
        """
        logging.debug("Removing deleted entries")
        hosts = {}
        if ('pools' in self.current and self.current['pools']):
            for pool in self.current['pools']: 
                hosts[pool['pool']] = []
                # Add current gateways
                if 'gateways' in pool:
                    for gateway in pool['gateways']:
                        if 'host' in gateway:
                            hosts[pool['pool']].append(gateway['host'])
                        if 'target' in gateway:
                            hosts[pool['pool']].append(gateway['target'])
            for pool in self.submitted['pools']: 
                # Subtract submitted gateways, skip new entries
                if 'gateways' in pool:
                    for gateway in pool['gateways']:
                        if ('host' in gateway and
                            gateway['host'] in hosts[pool['pool']]):
                            hosts[pool['pool']].remove(gateway['host'])
                        if ('target' in gateway and 
                            gateway['target'] in hosts[pool['pool']]):
                            hosts[pool['pool']].remove(gateway['target'])
                # Remove difference
                for host in hosts[pool['pool']]:
                    self.attr.remove(str(pool['pool']), str(host))
                    logging.debug("Removing host {} from pool {}".format(host, pool))

    def _remove_absent_auth(self):
        """
        Remove auth section that has been deleted from the submitted 
        configuration
        """
        if ('auth' in self.current and self.current['auth'] 
            and not 'auth' in self.submitted):
            for pool in self.submitted['pools']: 
                self.attr.remove_auth(str(pool['pool']))

    def _write_host(self, pool, gateway):
        """
        Write a host entry
        """
        if 'host' in gateway:
            self.attr.write(str(pool['pool']), 
                str(gateway['host']), json.dumps(gateway))

    def _write_target(self, pool, gateway):
        """
        Write a target entry
        """
        if 'target' in gateway:
            self.attr.write(str(pool['pool']), 
                str(gateway['target']), json.dumps(gateway))

    def _write_auth(self, pool):
        """
        Write authentication entry for host or target 
        """
        for entry in self.submitted['auth']: 
            if 'host' in entry:
                self.attr.write(str(pool['pool']), 
                    str('_' + entry['host']), json.dumps(entry))
            elif 'target' in entry:
                self.attr.write(str(pool['pool']), 
                    str('_' + entry['target']), json.dumps(entry))
            else:
                raise ValueError("auth entry must contain either 'host' or 'target'")

    def _write_targets(self, pool):
        """
        Write targets section
        """
        self.attr.write(str(pool['pool']), 
            str('targets'), json.dumps(self.submitted['targets']))

    def _write_portals(self, pool):
        """
        Write portals section
        """
        self.attr.write(str(pool['pool']), 
            str('portals'), json.dumps(self.submitted['portals']))

class Cluster:
    """
    Support 'with' for Rados connections
    """

    def __init__(self):
        """
        Capture pool name
        """
        self.cluster = None

    def __enter__(self):
        """
        Connect to Ceph, return connection
        """
        self.cluster = rados.Rados(conffile=Common.ceph_conf)
        try:
            self.cluster.connect()
        except rados.ObjectNotFound, e:
            raise IOError("check for missing keyring")
        return(self.cluster)

    def __exit__(self, exc_ty, exc_val, tb):
        """
        Close connection
        """
        self.cluster.shutdown()

class Ioctx:
    """
    Support 'with' for pool connections
    """

    def __init__(self, cluster, pool):
        """
        Capture pool name
        """
        self.cluster = cluster
        self.ioctx = None
        self.pool = pool

    def __enter__(self):
        """
        Connect to Ceph, open pool, return connection
        """
        try:
            self.ioctx = self.cluster.open_ioctx(self.pool)
        except rados.ObjectNotFound, e:
            raise RuntimeError("pool '{}' does not exist".format(self.pool))
        return(self.ioctx)

    def __exit__(self, exc_ty, exc_val, tb):
        """
        Close pool
        """
        self.ioctx.close()

class Attributes:
    """
    Methods for updating and removing extended attributes within Ceph.
    """

    def __init__(self, cluster):
        self.cluster = cluster
        pass

    def write(self, pool, key, attrs):
        """
        Write an empty object and set an extended attribute

            pool - a string, name of Ceph pool
            key - a string, name of gateway host or target
            attrs - a string, json format
        """
        conn = Ioctx(self.cluster, pool)
        with conn as ioctx:
            ioctx.write_full(Common.config_name, "")
            ioctx.set_xattr(Common.config_name, key, attrs)
            logging.debug("Writing {} to pool {}".format(key, pool))

    def remove(self, pool, attr):
        """
        Remove a specified attribute.  This is necessary when a host has
        been removed from the list of gateways
  
            pool - a string, name of Ceph pool
            attr - a string, name of gateway host
        """
        conn = Ioctx(self.cluster, pool)
        with conn as ioctx:
            ioctx.rm_xattr(Common.config_name, attr)
            logging.debug("Removing {} from pool {}".format(attr, pool))

    def remove_auth(self, pool):
        """
        Remove authentication attributes for a pool

            pool - a string, name of Ceph pool
        """
        conn = Ioctx(self.cluster, pool)
        with conn as ioctx:
            for key, value in ioctx.get_xattrs(Common.config_name):
                if (key[0] == "_"):
                    ioctx.rm_xattr(Common.config_name, key)
                    logging.debug("Removing {} from pool {}".format(key, pool))


class Pools:
    """
    Manages the entire structure of pools, gateways, tpg and initiators.  
    All hosts are included.
    """

    def __init__(self):
        """
        A list of pools.  Data structure is label : value throughout. 
        """
        self.pools = []

    def add(self, item):
        """
        Creates another pool entry
        
            item - dict (e.g. "pool": "swimming")
        """
        self.pools.append(OrderedDict())
        self.pools[-1]['pool'] = item

    def append(self, key, item):
        """
        Adds another JSON structure to 'key' in the same named pool above.

            key - a string such as "gateways"
            item - JSON structure of host, tpg and portals
        """
        if not key in self.pools[-1]:
            self.pools[-1][key] = []
        self.pools[-1][key].append(item)

    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.pools)

class PortalSection:
    """
    Manages the portal section of the extended attributes (i.e. all data stored 
    under portals).
    """

    def __init__(self):
        """
        List of portals, entries are name and addresses
        """
        self.portals = []

    def add(self, item):
        """
        Add entire structure, identical copies are stored in each pool so 
        only one is needed.
        """
        if not self.portals and item:
            self.portals.extend(item)

    def purge(self, portals):
        for entry in self.portals:
            if not entry['name'] in portals:
                self.portals.remove(entry)

    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.portals)

class Targets:
    """
    Manages the target section of the extended attributes (i.e. all data stored 
    under targets).
    """

    def __init__(self):
        """
        List of targets, entries are either host and iqn or hosts and iqn
        """
        self.targets = []

    def add(self, item):
        """
        Add entire structure, identical copies are stored in each pool so 
        only one is needed.
        """
        if not self.targets and item:
            self.targets.extend(item)

    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.targets)
     
    def list(self):
        """
        Return only iqn values filtered by hostname
        """
        targets = []
        for entry in self.targets:
            if 'hosts' in entry:
                for host in entry['hosts']:
                    if (Common.hostname == host):
                        targets.append(entry['target'])
        return(targets)

    def purge(self):
        """
        Remove all host entries that do not match hostname
        """
        for entry in self.targets:
            if 'host' in entry:
                if (Common.hostname != entry['host']):
                       self.targets.remove(entry)
            if 'hosts' in entry:
                if not Common.hostname in entry['hosts']:
                       self.targets.remove(entry)

class Authentications:
    """
    Manages the authentication section under the extended attribute auth.
    This section is optional, but relates to gateways and targets 
    independently.  Authentication can be none, tpg (common credentials) or
    acls (host specific credentials).
    """

    def __init__(self):
        """
        List of authentications.  Absent and present but disabled are 
        permitted.
        """
        self.authentications = []

    def add(self, item):
        """
        Add entire structure, identical copies are stored in each pool so 
        only one is needed.
        """
        if not self._exists(item):
            self.authentications.append(item)

    def _exists(self, item):
        """
        helper function for above since "item in list" didn't work for
        list of lists
        """
        present = False
        for entry in self.authentications:
            for attr in [ 'host', 'target' ]:
                if attr in item and attr in entry:
                    if (item[attr] == entry[attr]):
                        present = True
                        break
        return(present)

    def purge(self):
        for entry in self.authentications:
            if 'host' in entry:
                if (Common.hostname != entry['host']):
                    self.authentications.remove(entry)


    def display(self):
        """
        Useful for debugging
        """
        pprint.pprint(self.authentications)


class Configs:
    """
    Read the configuration from Ceph for both global and host only 
    configurations.  Merges pools, targets and authentications into
    larger structures.  Assigns to Common.* for sharing with other
    classes.
    """

    def __init__(self, config_name, ceph_conf, hostname):
        """
        Set initial overrides and assign to Common configuration

            config_name - a string for the name of the configuration object
                          in Ceph
            ceph_conf - an alternative Ceph configuration file
            hostname - specify an alternative gateway host
        """
        self.config_name = config_name if config_name else "lrbd.conf"
        self.ceph_conf = ceph_conf if ceph_conf else "/etc/ceph/ceph.conf"


        if not os.path.isfile(self.ceph_conf):
            raise IOError("{} does not exist".format(self.ceph_conf))

        self.hostname = hostname if hostname else socket.gethostname()

        Common.config_name = self.config_name
        Common.ceph_conf = self.ceph_conf
        Common.hostname = self.hostname

    def retrieve(self, filter=None):
        """
        Scan all configuration objects and build a structure containing
        all gateway hosts.  Merge pools, auth, portals and targets into 
        Common.config 
        """
        conn = Cluster()
        with conn as cluster:
            p = Pools()
            pt = PortalSection()
            t = Targets()
            a = Authentications()

            portals = []
            for pool in cluster.list_pools():
                conn = Ioctx(cluster, pool)
                with conn as ioctx:

                    if self._config_missing(ioctx, self.config_name, pool):
                        continue
                    p.add(pool)
                    t.add(self._get_optional(ioctx, self.config_name, 'targets'))
                    pt.add(self._get_optional(ioctx, self.config_name, 'portals'))
                    
                    if filter:
                        targets = t.list()
                        

                    attrs = ioctx.get_xattrs(self.config_name)
                    for key, value in attrs:
                        if key == "targets" or key == "portals":
                            continue
                        elif key[0] == "_":
                            a.add(json.loads(value, 
                                object_pairs_hook=OrderedDict))
                        else:
                            if filter:
                                if (key in targets or key == self.hostname):
                                    content = json.loads(value,
                                        object_pairs_hook=OrderedDict)
                                    p.append('gateways', content)
                                    for entry in content['tpg']:
                                        if 'portal' in entry:
                                            portals.append(entry['portal'])
                            else:
                                p.append('gateways', json.loads(value, 
                                    object_pairs_hook=OrderedDict))

        if filter:
            t.purge()
            a.purge()
            pt.purge(portals)

        Common.config['auth'] = a.authentications
        Common.config['targets'] = t.targets
        Common.config['portals'] = pt.portals
        Common.config['pools'] = p.pools

    def _config_missing(self, ioctx, config_name, pool):
        """
        Check for configuration object

            ioctx - existing pool connection
            config_name - name of the configuration object
            pool - name of pool
        """
        try:
            ioctx.stat(config_name) # Check for object
        except rados.ObjectNotFound, e:
            # No configuration for pool, skipping
            logging.info("No configuration object {} in pool {}".format(self.config_name, pool))
            return(True)
        return(False)

    def _get_optional(self, ioctx, config_name, attr):
        """
        Load value of specified attribute, may not exist

            ioctx - existing pool connection
            config_name - name of the configuration object
            attr - key desired (e.g. 'targets' or 'portals')
        """
        try:
            return(json.loads(ioctx.get_xattr(config_name, attr), object_pairs_hook=OrderedDict))
        except rados.NoData, e:
            pass

    def display(self):
        """
        JSON dump of structure to user.  Keys are sorted which makes the 
        format obnoxious when reviewing.  TODO: custom JSON output with
        keys sorted by significance.
        """
        print json.dumps(Common.config, indent=4)

    def wipe(self):
        """
        Remove configuration objects from all pools
        """
        cluster = rados.Rados(conffile=self.ceph_conf)

        cluster.connect()
        pools = cluster.list_pools()
        for pool in pools:
            ioctx = cluster.open_ioctx(pool)
            try:
                ioctx.remove_object(self.config_name)
                logging.debug("Removing {} from pool {}".format(self.config_name, pool))
            except rados.ObjectNotFound, e:
                logging.info("No object {} to remove from pool {}".format(self.config_name, pool))
            ioctx.close
        cluster.shutdown()

    def clear(self):
        """
        Reset any targetcli configuration.  

        Note: the clearconfig option is missing from the current targetcli
        which would remove the additional dependencies
        """
        cmds = [ [ "/usr/sbin/tcm_fabric", "--unloadall" ],
                 [ "/usr/sbin/lio_node", "--unload" ],
                 [ "/usr/sbin/tcm_node", "--unload" ] ]
        for cmd in cmds:
            popen(cmd)


##########################################################################
# Ideal spot for separating into another file.  All classes and functions
# below change the host system.
##########################################################################
def entries():
    """
    Generator yielding pool, gateway and tpg entries
    """
    for pentry in Common.config['pools']:
        if 'gateways' in pentry:
            for gentry in pentry['gateways']:
                for entry in gentry['tpg']:
                    yield (pentry, gentry, entry)

class Images:
    """
    Manages mapping and unmapping RBD images
    """

    def __init__(self):
        """
        Parse and store 'rbd showmapped'
        """
        self.mounts = {}
        proc = Popen(["rbd", "showmapped"], stdout=PIPE, stderr=PIPE)
        for line in proc.stdout:
                results = re.split(r'\s+', line)
                if (results[0] == 'id'):
                    continue
                self.mounts[ ":".join([ results[1], results[2] ]) ] = results[4]  

    def map(self):
        """
        Create the commands to map each rbd device
        """
        self.map_cmds = []
        
        for pentry, gentry, entry in entries():
           if ":".join([ pentry['pool'], entry['image'] ]) in self.mounts.keys():
               continue
           self.map_cmds.append([ "rbd", "-p", pentry['pool'], "map", entry['image'] ])

        for cmd in self.map_cmds:
            popen(cmd)

    def unmap(self):
        """
        Unmount all rbd images
        """
        for mount in self.mounts.keys():
            popen([ "rbd", "unmap", self.mounts[mount]])


class Backstores:
    """
    Creates the necessary backstores via targetcli for each RBD image.
    """

    def __init__(self, backstore):
        """
        Create commands for creating each backstore.  Skip existing. 
        """
        self.cmds = []
        if (backstore == "rbd"):
            self._load_modules()
            self._rbd()
            Runtime.config['backstore'] = "rbd"
        else:
            self._iblock()
            Runtime.config['backstore'] = "iblock"


    def _iblock(self):
        """
        The traditional backstore for iSCSI.  Does not support simultaneous
        multipath access.
        """
        for pentry, gentry, entry in entries():
           cmd = [ "targetcli", "/backstores/iblock", "create", 
                   "name={}".format(entry['image']), 
                   "dev=/dev/rbd/{}/{}".format(pentry['pool'], entry['image']) ]
           backstore = glob.glob(TARGET + "/core/iblock_*/{}".format(entry['image']))
           if not backstore: 
               self.cmds.append(cmd)

    def _rbd(self):
        """
        The new backstore for iSCSI.  Supports simultaneous multipath access.
        """
        for pentry, gentry, entry in entries():
           self._rbd_setup("/dev/rbd/{}/{}".format(pentry['pool'], 
                               entry['image']))
           cmd = [ "targetcli", "/backstores/rbd", "create", 
                   "name={}".format(entry['image']), 
                   "dev=/dev/rbd/{}/{}".format(pentry['pool'], entry['image']) ]
           backstore = glob.glob(TARGET + "/core/rbd_*/{}".format(entry['image']))
           if not backstore: 
               self.cmds.append(cmd)

    def _rbd_setup(self, device):
        """
        Directory creation, control file creation are prerequisites for the
        rbd backstore.
        """
        rbds = []
        for path in glob.glob(TARGET + "/core/rbd_*"):
            rbds.append(int(re.split("[/_]", path)[7]))
        for num in range(100):
            if num in rbds:
                continue
            path = TARGET + "/core/rbd_{}/mylun".format(num)
            os.makedirs(path)
            with open(path + "/control", "w") as control:
                control.write("udev_path={}".format(device))
            return()
        logging.warning("Over 100 images mapped")

    def _load_modules(self):
        """
        Same kernel modules as targetcli + target_core_rbd 
        """
        modules = [ "vhost_scsi", "iscsi_target_mod", "tcm_loop", "tcm_fc",
                    "ib_srpt", "tcm_qla2xxx", "target_core_rbd" ]
        for module in modules:
            if not os.path.isdir("/sys/module/{}".format(module)):
                popen([ "modprobe", module ])

    def create(self):
        """
        Execute saved commands
        """
        for cmd in uniq(self.cmds):
            popen(cmd)

class Iscsi:
    """
    Creates iscsi entries with provided static target iqns or dynamically
    generates one if none are provided.
    """

    def __init__(self):
        """
        Find all target entries in targets.  Append to cmds all that do not 
        exist.  If no targets are provided, set cmds to a single base command.
        """
        self.cmds = []
        self.iqns = []
        for entry in Common.config['targets']:
            self.iqns.append(entry['target'])
            if 'hosts' in entry and Runtime.config['backstore'] == "iblock":
                logging.warning("Multiple gateway targets not supported with iblock backend, use rbd backend\n") 

        self._gen_wwn()

        base = [ "targetcli", "/iscsi", "create" ]

        if self.iqns:
            for iqn in self.iqns:
                path = glob.glob(TARGET + "/iscsi/{}".format(iqn))
                if not path:
                    cmd = list(base)
                    cmd.append(iqn)
                    self.cmds.append(cmd)
        else:
            cmd = base
            self.cmds.append(cmd)

    def _gen_wwn(self):
        """
        generate the same wwn for targets on multiple gateways 
        """
        # has to be unique for target and image 
        if 'pools' in Common.config:
            for pentry, gentry, entry in entries():
                if 'target' in gentry:
                    _uuid = uuid.uuid3(uuid.NAMESPACE_DNS, 
                                str(gentry['target'] + entry['image']))
                    logging.debug("For image {} on target {}\nuuid: {}".format(entry['image'], gentry['target'], _uuid))
                    path = glob.glob(TARGET + "/core/{}_*/{}/wwn/vpd_unit_serial".format(Runtime.config['backstore'], entry['image']))
                    vus = open(path[0], "w")
                    vus.write(str(_uuid) + "\n")
                    vus.close()


    def create(self):
        """
        Execute commands and assign list of targets to Common.config['iqns']
        """
        for cmd in self.cmds:
            popen(cmd)
        if self.iqns:
            Common.config['iqns'] = self.iqns
        else:
            path = glob.glob(TARGET + "/iscsi/iqn*")
            Common.config['iqns'] = [ basename(path[0]) ]
        logging.debug("Common.config['iqns']: {}".format(Common.config['iqns']))


class TPGs:
    """
    Creates any additional TPGs needed.
    """

    def __init__(self):
        """
        Track several states.  

            self.cmds - final list of commands to be executed
            self.remote - TPG for holding remote gateway portals per target
            self.tpg - running counter of TPG per target
            self.portals - maps each portal to TPG per target
        """
        self.cmds = []
        self.remote = {}
        self.pools = Common.config['pools']
        Runtime.config['addresses'] = addresses()

        self.tpg = {}
        self.portals = {}

        self._add()
        self._remote()
        Runtime.config['remote'] = self.remote
        Runtime.config['portals'] = self.portals

    def _add(self):
        """
        Adds a TPG for each portal group.  Since iscsi.create() makes tpg1,
        skips that one naturally.
        """
        for pentry, gentry, entry in entries():
            target = iqn(gentry)
            if not target in self.remote:
                self.remote[target] = None
            if not target in self.tpg:
                self.tpg[target] = 1
            if not target in self.portals:
                self.portals[target] = {}
            if ('portal' in entry and 
                not entry['portal'] in self.portals[target]):
                self._check_portal(entry['portal'])
                self.portals[target][entry['portal']] = self.tpg[target]
                self.tpg[target] += 1 
                self.cmds.append(self._cmd(target, 
                                 self.portals[target][entry['portal']]))
                logging.debug("Adding TPG {} for target {}".format(self.portals[target][entry['portal']], target))

                    
    def _check_portal(self, name):
        """
        Check that the referenced portal is defined in portals
        """
        found = False
        for entry in Common.config['portals']:
            if name == entry['name']:
                found = True
                break
        if not found:
            raise ValueError("portal {} is missing from portals".format(name))

    def _remote(self):
        """
        Adds a TPG for holding remote gateway portals.  Checks each target.
        """
        
        for target in self.portals.keys():
            for name in self.portals[target].keys():
                for entry in Common.config['portals']:
                    if name == entry['name']:
                        for address in entry['addresses']:
                            addr = re.split(" ", address)[0]
                            if not addr in Runtime.config['addresses']:
                                if not self.remote[target]:
                                    self.remote[target] = self.tpg[target]
                                    self.cmds.append(self._cmd(target, 
                                                         self.tpg[target]))
                                    logging.debug("Adding TPG {} for target {}".format(self.tpg[target], target))
                
    def disable_remote(self):
        """
        Disable TPG and disable tpg_enabled_sendtargets.
        """
        for target in Runtime.config['remote'].keys():
            tpg = Runtime.config['remote'][target]
            if not tpg:
                continue
            path = TARGET + "/iscsi/{}/tpgt_{}/attrib/tpg_enabled_sendtargets".format(target, tpg)
            if not os.path.isfile(path):
                raise RuntimeError("tpg_enabled_sendtargets unsupported, upgrade kernel to 3.12.46-102-default or higher")
            tes = open(path, "w")
            tes.write("0")
            tes.close()
            logging.debug("Disabling tpg_enabled_sendtargets")
            tpg_path = TARGET + "/iscsi/{}/tpgt_{}/enable".format(target, tpg)
            enabled = open(tpg_path).read().rstrip('\n')
            if (enabled == "1"):
                popen([ "targetcli", "/iscsi/{}/tpg{}".format(target, tpg), "disable" ])


    def _cmd(self, target, tpg):
        """
        Return targetcli command if configfs entry is not present
        """
        path = glob.glob(TARGET + "/iscsi/{}/tpgt_{}".format(target, tpg))
        if not path:
            return([ "targetcli", "/iscsi/{}".format(target), 
                         "create {}".format(tpg) ])
        return([])

    def create(self):
        """
        Execute commands and assign list of targets to Common.config['iqns']
        """
        for cmd in self.cmds:
            if cmd:
                popen(cmd)
        

class Portals:
    """
    Manage the creation of portals, skipping existing.  If none are provided
    in the configuration, assign the base targetcli command which selects
    a default interface.
    """

    def __init__(self):
        """
        Build portal commands, assign address to correct TPG
        """
        self.cmds = []
        self.luns = []

        if 'portals' in Common.config and Common.config['portals']:
            for target, portal, entry in self._entries():
                if entry['name'] == portal:
                    for address in entry['addresses']:
                        # Strip Port 
                        addr = re.split(" ", address)[0]
                        if addr in Runtime.config['addresses']:
                            self._cmd(target, 
                                 Runtime.config['portals'][target][portal], 
                                 address)
                            logging.debug("Adding address {} to tpg {} under target {}".format(address, Runtime.config['portals'][target][portal], target))
                        else:
                            self._cmd(target, 
                                 Runtime.config['remote'][target], 
                                 address)
                            logging.debug("Adding address {} to tpg {} under target {}".format(address, Runtime.config['remote'][target], target))
        else:
            self._cmd(iqn({}), "1", "")
                        

    def _entries(self):
        """
        Generator
        """
        for target in Runtime.config['portals'].keys():
            for portal in Runtime.config['portals'][target]:
                self._check(portal)
                for entry in Common.config['portals']:
                    yield(target, portal, entry)


    def _check(self, name):
        found = False
        for entry in Common.config['portals']:
            if entry['name'] == name:
                found = True
        if not found:
            raise ValueError("portal {} missing from portals section".format(name))
            
         


    def _cmd(self, target, tpg, address):
        """
        Compose targetcli commmand for creating portal if needed.
        """
        cmd = [ "targetcli", "/iscsi/{}/tpg{}/portals".format(target, tpg), "create", address ] 
        portal = glob.glob(TARGET + "/iscsi/{}/tpgt_{}/np/{}*".format(target, tpg, address))
        if not portal:
            self.cmds.append(cmd)


    def create(self):
        """
        Execute saved commands.  Skip redundant commands from multiple image
        entries.
        """
        for cmd in uniq(self.cmds):
            popen(cmd)

class Luns:
    """
    Manages the creation and mapping of luns.  Also, provides method for 
    disabling auto add which is necessary for acls.
    """

    def __init__(self):
        """
        Skips existing luns.  Builds commands for each image under the 
        correct target.
        """
        self.cmds = []
        self.luns = []
                
        self._find()

        for pentry, gentry, entry in entries():
            if not entry['image'] in self.luns:
                target = iqn(gentry)
                tpg = Runtime.tpg(target, entry)
                self._cmd(target, tpg, entry['image'])
                logging.debug("Adding lun for image {} to tpg {} under target {}".format(entry['image'], tpg, target))
                
    def _find(self):
        """
        Scan paths for existing luns and save lun name to list
        """
        for pentry, gentry, entry in entries():
            udev_paths = glob.glob(TARGET + "/iscsi/{}/tpgt_*/lun/lun_*/*/udev_path".format(iqn(entry)))
            for udev_path in udev_paths:
                contents = open(udev_path).read()
                self.luns.append(basename(contents.rstrip('\n')))

    def _cmd(self, target, tpg, image):
        """
        Compose targetcli commmand for creating lun if needed.
        """
        if (Runtime.config['backstore'] == "rbd"):
            cmd = [ "targetcli", "/iscsi/{}/tpg{}/luns".format(target, tpg), "create", "/backstores/rbd/{}".format(image) ] 
        else:
            cmd = [ "targetcli", "/iscsi/{}/tpg{}/luns".format(target, tpg), "create", "/backstores/iblock/{}".format(image) ] 
        self.cmds.append(cmd)

    def create(self):
        """
        Disable auto mapping.  Execute saved commands.
        """
        self.disable_auto_add_mapped_luns()
        for cmd in uniq(self.cmds):
            popen(cmd)

    def disable_auto_add_mapped_luns(self):
        """
        Allow device to initiator mapping by disabling auto mapping.
        """
        proc = Popen(["targetcli", "get", "global", "auto_add_mapped_luns"], stdout=PIPE, stderr=PIPE)
        for line in proc.stdout:
            results = re.split(r'=', line)
            if (results[1].rstrip() != 'false'):
                cmd = [ "targetcli", "set", "global", "auto_add_mapped_luns=false" ]
                popen(cmd)

class Map:

    def __init__(self):
        """
        Creates mapped luns under each initiator.  Skips existing. 
        """
        self.cmds = []
        self.luns = []

        for pentry, gentry, entry in entries():
            target = iqn(gentry)
            tpg = Runtime.tpg(target, entry)
            lun = self._lun(target, tpg, entry['image'])
            self._check(target, tpg, entry['initiator'])
            self._cmd(target, tpg, entry['initiator'], lun)
            logging.debug("Mapping lun {} for initiator {} to tpg {} under target {}".format(lun, entry['initiator'], tpg, target))
              

    def _lun(self, target, tpg, image):
        """
        Return the numeric value of the lun for this image

            image - name of RBD image
        """
        lun_path = glob.glob(TARGET + "/iscsi/{}/tpgt_{}/lun/lun_*/*".format(target, tpg))
        for p in lun_path:
            if (basename(os.path.realpath(p)) == image):
                return(re.split("[/_]", p)[11])
          
        raise ValueError("lun missing from tpg{} under target {}".format(tpg, target))

    def _check(self, target, tpg, initiator):
        """
        Check that acl exists, otherwise, raise exception

            target - iqn of the target
            tpg - number of tpg, most likely "1"
            initiator - iqn of client
        """
        path = glob.glob(TARGET + "/iscsi/{}/tpgt_{}/acls/{}".format(target, tpg, initiator))
        if not path:
            raise ValueError("ERROR: acl missing for initiator {} under tpg {} under target {}".format(initiator, tpg, target))

    def _cmd(self, target, tpg, initiator, lun):
        """
        Compose command to create a mapped lun.  Skip if exists.

            target - iqn of the target
            tpg - number of tpg, most likely "1"
            initiator - iqn of client
            lun - number for block device of RBD image
        """
        path = glob.glob(TARGET + "/iscsi/{}/tpgt_{}/acls/{}/lun_{}".format(target, tpg, initiator, lun))
        if not path:
            self.cmds.append([ "targetcli", "/iscsi/{}/tpg{}/acls/{}".format(target, tpg, initiator), "create", lun, lun ])

    def map(self):
        """
        Execute saved commands.
        """
        for cmd in self.cmds:
            popen(cmd)


class Acls:
    """
    Manage acls for each initiator.  Skip existing entries.  

    """

    def __init__(self):
        """
        Create acl under correct tpg per target.  Skip existing.  
        Scan portal addresses for remote gateways.  Create acl under remote 
        tpg, if necessary.
        """
        self.cmds = []
        self.initiators = []

        self._find()
        for pentry, gentry, entry in entries():
            if not 'initiator' in entry:
                raise ValueError("initiator missing from host {}".format(gentry['host']))
            if not entry['initiator'] in self.initiators:
                target = iqn(gentry)
                tpg = Runtime.tpg(target, entry)
                self._cmd(target, tpg, entry['initiator'])
                for poentry in Common.config['portals']:
                    if (poentry['name'] == entry['portal']):
                        for address in poentry['addresses']:
                            addr = re.split(" ", address)[0]
                            if not addr in Runtime.config['addresses']:
                                tpg = Runtime.config['remote'][target]
                                self._cmd(target, tpg, entry['initiator'])
                                logging.debug("Adding initiator {} to tpg {} under target {}".format(entry['initiator'], tpg, target))
                    
    def _find(self):
        """
        Add existing initiators to list
        """
        for pentry in Common.config['pools']:
            if 'gateways' in pentry:
                for gentry in pentry['gateways']:
                    paths = glob.glob(TARGET + "/iscsi/{}/tpgt_*/acls/*".format(iqn(gentry)))
                    for path in paths:
                        self.initiators.append(basename(path))

    def _cmd(self, target, tpg, initiator):
        """
        Compose targetcli command for creating an acl.  Append to list.
        """
        cmd = [ "targetcli", "/iscsi/{}/tpg{}/acls".format(target, tpg), "create", initiator ] 
        self.cmds.append(cmd) 
               
    def create(self):
        """
        Execute unique, saved commands
        """
        for cmd in uniq(self.cmds):
            popen(cmd)


class Auth:
    """
    Manage the authentications for each target.  Each authentication mode
    contains multiple steps.  Delegate creation of the necessary commands.  
    Execute commands.
    """

    def __init__(self):
        """
        Check for existence of the authentication section and current setting.
        Select appropriate delegation.  Note that discovery authentication
        is independent of normal authentication and optional.
        """
        self.cmds = []

        if 'auth' in Common.config:
            for auth in Common.config['auth']:
                self.target = iqn(auth)
                if auth['authentication'] == "none":
                    self.cmds.append(self.set_noauth(auth))
                elif auth['authentication'] == "tpg":
                    self.cmds.extend(self.select_tpg(auth))
                elif auth['authentication'] == "acls":
                    self.cmds.extend(self.select_acls(auth))
                else:
                    raise ValueError("InvalidAuthentication: authentication must be one of tpg, acls or none")
                self.cmds.extend(self.select_discovery())
        else:
            self.cmds.append(self.set_noauth({}))

    def set_noauth(self, auth):
        """
        Disable authentication
        """
        logging.debug("Disable authentication")
        path = TARGET + "/iscsi/{}/tpgt_1/attrib".format(iqn(auth))
        authentication = open(path + "/authentication").read().rstrip('\n')
        demo_mode_write_protect = open(path + "/demo_mode_write_protect").read().rstrip('\n')
        
        if ((authentication == "0") and
           (demo_mode_write_protect == "0")):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1".format(iqn(auth)), "set", "attribute", "authentication=0", "demo_mode_write_protect=0" ] 
        return(cmd)

    def select_discovery(self):
        """
        Discovery is optional, can be completely disabled, have only mutual 
        disabled or be completely enabled.  Delegate appropriately.
        """
        cmds = []
        for auth in Common.config['auth']:
            if "discovery" in auth:
                if auth['discovery']['auth'] == "enable":
                    if "mutual" in auth['discovery']:
                        if auth['discovery']['mutual'] == "enable":
                            cmds.append(self.set_discovery_mutual(auth))
                        else:
                            cmds.append(self.set_discovery(auth))
                    else:
                        cmds.append(self.set_discovery(auth))
                else:
                    cmds.append(self.set_discovery_off())
            else:
                cmds.append(self.set_discovery_off())
            return(cmds)

    def set_discovery(self, auth):
        """
        Call targetcli to only set the discovery userid and password.  Check
        current settings.
        """
        logging.debug("Set discovery authentication")
        keys = [ 'userid', 'password']
        check_keys(keys, auth['discovery'], "discovery under auth")

        path = TARGET + "/iscsi/discovery_auth"
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        
        if compare_settings(keys, current, auth['discovery']):
            return([])

        cmd = [ "targetcli", "/iscsi", "set", "discovery_auth", "enable=1",
                 "userid={}".format(
                     auth['discovery']['userid']), 
                 "password={}".format(
                     auth['discovery']['password']) ] 
        return(cmd)

    def set_discovery_mutual(self, auth):
        """
        Call targetcli to set both normal and mutual discovery authentication.
        Checks current settings.
        """
        logging.debug("Set discovery and mutual authentication")
        keys = [ 'userid', 'password', 'userid_mutual', 'password_mutual']
        check_keys(keys, auth['discovery'], "discovery under auth")

        path = TARGET + "/iscsi/discovery_auth"
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        current['userid_mutual'] = open(path + "/userid_mutual").read().rstrip('\n')
        current['password_mutual'] = open(path + "/password_mutual").read().rstrip('\n')
        
        if compare_settings(keys, current, auth['discovery']):
            return([])


        cmd = [ "targetcli", "/iscsi", "set", "discovery_auth", "enable=1", 
                 "userid={}".format(
                     auth['discovery']['userid']), 
                 "password={}".format(
                     auth['discovery']['password']), 
                 "mutual_userid={}".format(
                     auth['discovery']['userid_mutual']), 
                 "mutual_password={}".format(
                     auth['discovery']['password_mutual']) ] 
        return(cmd)

    def set_discovery_off(self):
        """
        Disable discovery
        """
        logging.debug("Disable discovery authentication")
        cmd = [ "targetcli", "/iscsi", "set", "discovery_auth", "enable=0" ]
        return(cmd)

    def select_tpg(self, auth):
        """
        TPG is optional, can have only mutual disabled or be completely 
        enabled.  Delegate appropriately.  TPG allows a common userid and
        password for all initiators.
        """
        cmds = []
        if "mutual" in auth['tpg']:
            if auth['tpg']['mutual'] == "enable":
                cmds.append(self.set_tpg_mutual(auth))
                cmds.append(self.set_tpg_mode(auth))
            else:    
                cmds.append(self.set_tpg(auth))
                cmds.append(self.set_tpg_mode(auth))
        else:
            cmds.append(self.set_tpg(auth))
            cmds.append(self.set_tpg_mode(auth))
        return(cmds)


    def set_tpg(self, auth):
        """
        Call targetcli to set only the common userid and password.  Check
        current setting.
        """
        logging.debug("Set tpg authentication")
        keys = [ 'userid', 'password']
        check_keys(keys, auth['tpg'], "tpg under auth")
                
        path = TARGET + "/iscsi/{}/tpgt_1/auth".format(iqn(auth))
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        
        if compare_settings(keys, current, auth['tpg']):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1".format(iqn(auth)), "set", "auth", 
                 "userid={}".format(
                     auth['tpg']['userid']), 
                 "password={}".format(
                     auth['tpg']['password']) ] 
        return(cmd)

    def set_tpg_mutual(self, auth):
        """
        Call targetcli to set both the common and mutual userids and passwords.
        Checks current settings.
        """
        logging.debug("Set tpg and mutual authentication")
        keys = [ 'userid', 'password', 'userid_mutual', 'password_mutual']
        check_keys(keys, auth['tpg'], "tpg under auth")

        path = TARGET + "/iscsi/{}/tpgt_1/auth".format(iqn(auth))
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        current['userid_mutual'] = open(path + "/userid_mutual").read().rstrip('\n')
        current['password_mutual'] = open(path + "/password_mutual").read().rstrip('\n')
        
        if compare_settings(keys, current, auth['tpg']):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1".format(iqn(auth)), "set", "auth", 
                 "userid={}".format(
                     auth['tpg']['userid']), 
                 "password={}".format(
                     auth['tpg']['password']), 
                 "userid_mutual={}".format(
                     auth['tpg']['userid_mutual']), 
                 "password_mutual={}".format(
                     auth['tpg']['password_mutual']) ] 
        return(cmd)

    def set_tpg_mode(self, auth):
        """
        Enable authentication, allow writing and enable acl generation. Checks
        current settings.
        """
        path = TARGET + "/iscsi/{}/tpgt_1/attrib".format(iqn(auth))
        authentication = open(path + "/authentication").read().rstrip('\n')
        demo_mode_write_protect = open(path + "/demo_mode_write_protect").read().rstrip('\n')
        generate_node_acls = open(path + "/generate_node_acls").read().rstrip('\n')
        
        if ((authentication == "1") and
           (demo_mode_write_protect == "0") and
           (generate_node_acls  == "1")): 
            return([])

        return([ "targetcli", "/iscsi/{}/tpg1".format(iqn(auth)), "set", "attribute", "authentication=1", "demo_mode_write_protect=0", "generate_node_acls=1" ]) 

    def select_acls(self, auth):
        """
        ACLs are optional, can have only mutual disabled or be completely 
        enabled for each initiator.  Delegate appropriately.  ACLs allow a 
        unique userid and password for each initiator.
        
        """
        cmds = []
        for acl in auth['acls']:
            if "mutual" in acl:
                if acl['mutual'] == "enable":
                    cmds.append(self.set_acls_mutual(acl, auth))
                else:
                    cmds.append(self.set_acls(acl, auth))
            else:
                cmds.append(self.set_acls(acl, auth))
        cmds.append(self.set_acls_mode(auth))
        return(cmds)
 
    def set_acls(self, acl, auth):
        """
        Call targetcli to set a userid and password for a specific initiator.
        Checks current setting.
        """
        logging.debug("Set acl authentication")
        keys = [ 'userid', 'password']
        check_keys(keys, acl, "acl")

        path = TARGET + "/iscsi/{}/tpgt_1/acls/{}/auth".format(iqn(auth), acl['initiator'])
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        
        if compare_settings(keys, current, acl):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1/acls/{}".format(iqn(auth), acl['initiator']), "set", "auth", 
                 "userid={}".format(acl['userid']),
                 "password={}".format(acl['password']), ] 
        return(cmd)

    def set_acls_mutual(self, acl, auth):
        """
        Call targetcli to set both a normal and mutual authentication for 
        an initiator.  Checks current settings.
        """
        logging.debug("Set acl and mutual authentication")
        keys = [ 'userid', 'password', 'userid_mutual', 'password_mutual']
        check_keys(keys, acl, "acl")

        path = TARGET + "/iscsi/{}/tpgt_1/acls/{}/auth".format(iqn(auth), acl['initiator'])
        current = {}
        current['userid'] = open(path + "/userid").read().rstrip('\n')
        current['password'] = open(path + "/password").read().rstrip('\n')
        current['userid_mutual'] = open(path + "/userid_mutual").read().rstrip('\n')
        current['password_mutual'] = open(path + "/password_mutual").read().rstrip('\n')

        if compare_settings(keys, current, acl):
            return([])

        cmd = [ "targetcli", "/iscsi/{}/tpg1/acls/{}".format(iqn(auth), acl['initiator']), "set", "auth", 
                 "userid={}".format(acl['userid']),
                 "password={}".format(acl['password']), 
                 "userid_mutual={}".format(acl['userid_mutual']),
                 "password_mutual={}".format(acl['password_mutual']) ] 
        return(cmd)

    def set_acls_mode(self, auth):
        """
        Enable authentication, disable acls generation.  Checks current settings.
        """
        path = TARGET + "/iscsi/{}/tpgt_1/attrib".format(iqn(auth))
        authentication = open(path + "/authentication").read().rstrip('\n')
        demo_mode_write_protect = open(path + "/demo_mode_write_protect").read().rstrip('\n')
        generate_node_acls = open(path + "/generate_node_acls").read().rstrip('\n')
        
        if ((authentication == "1") and
           (demo_mode_write_protect == "0") and
           (generate_node_acls  == "0")): 
            return([])
        return([ "targetcli", "/iscsi/{}/tpg1".format(iqn(auth)), "set", "attribute", "authentication=1", "demo_mode_write_protect=0", "generate_node_acls=0" ]) 

    def create(self):
        for cmd in self.cmds:
            if cmd:
                popen(cmd)


def main(args):
    """
    Apply stored configuration by default.  Otherwise, execute the alternate
    path from the specified options. 

        args - expects parse_args() result from argparse
    """
    configs = Configs(args.config, args.ceph, args.host)
    logging.basicConfig(format='%(levelname)s: %(message)s')

    if (args.verbose or args.wipe or args.host):
        logging.getLogger().level = logging.INFO

    if (args.debug):
        logging.getLogger().level = logging.DEBUG

    if (args.wipe):
        configs.wipe()
    elif (args.clear):
        configs.clear()
        if (args.unmap):
            images = Images()
            images.unmap()
    elif (args.unmap):
        images = Images()
        images.unmap()
    elif (args.file):
        configs.wipe()
        content = Content()
        content.read(args.file)
        content.save()
    elif (args.add):
        content = Content()
        content.read(args.add)
        content.save()
    elif (args.output):
        configs.retrieve()
        configs.display()
    elif (args.edit):
        configs.retrieve()
        content = Content()
        content.edit(args.editor)
        content.save()
    elif (args.local):
        configs.retrieve("host")
        configs.display()
    else:
        configs.retrieve("host")
        images = Images()
        images.map()
        backstores = Backstores(args.backstore)
        backstores.create()
        iscsi = Iscsi()
        iscsi.create()
        tpgs = TPGs()
        tpgs.create()
        tpgs.disable_remote()
        luns = Luns()
        luns.create()
        portals = Portals()
        portals.create()
        acls = Acls()
        acls.create()
        maps = Map()
        maps.map()
        auth = Auth()
        auth.create()


# Main
if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('-e', '--edit', action='store_true', dest='edit', default=False,
                    help='edit the rbd configuration for iSCSI')
    parser.add_argument('-E', '--editor', action='store', dest='editor',
                    help='use editor to edit the rbd configuration for iSCSI', metavar='editor')
    parser.add_argument('-c', '--config', action='store', dest='config',
                    help='use name for object, defaults to "lrbd.conf"', metavar='name')
    parser.add_argument('--ceph', action='store', dest='ceph',
                    help='specify the ceph configuration file', metavar='ceph')
    parser.add_argument('-H', '--host', action='store', dest='host',
                    help='specify the hostname, defaults to "{}"'.format(socket.gethostname()), metavar='host')
    parser.add_argument('-o', '--output', action='store_true', dest='output', 
                    help='display the configuration')
    parser.add_argument('-l', '--local', action='store_true', dest='local', 
                    help='display the host configuration')
    parser.add_argument('-f', '--file', action='store', dest='file', 
                    help='import the configuration from file', metavar='file')
    parser.add_argument('-a', '--add', action='store', dest='add', 
                    help='add the configuration from file', metavar='file')
    parser.add_argument('-u', '--unmap', action='store_true', dest='unmap', 
                    help='unmap the rbd images')
    parser.add_argument('-v', '--verbose', action='store_true', dest='verbose', 
                    help='print INFO messages')
    parser.add_argument('-d', '--debug', action='store_true', dest='debug', 
                    help='print DEBUG messages')
    parser.add_argument('-R', '--rbd', action='store_const', dest='backstore', 
                    const='rbd',
                    help='set the backstore to rbd, defaults to iblock')
    parser.add_argument('-W', '--wipe', action='store_true', dest='wipe', 
                    help='wipe the configuration objects from all pools')
    parser.add_argument('-C', '--clear', action='store_true', dest='clear', 
                    help='clear the targetcli configuration')
    
    args = parser.parse_args()
    
    if (args.editor != None):
        args.edit = True
    
    if args.debug:
        main(args)
    else:
        try:
            main(args)
        except SystemExit as e:
            print e
            exit()
        except Exception as e:
            logging.error(e)
            exit(1)

